package expressions

import (
	"testing"
)

// Спасибо ChatGPT, почти все тесты написал он

func TestValidate(t *testing.T) {
	testCases := []struct {
		infix    string
		expected bool
	}{
		{"1 + 2 + 6", true},
		{"1 + 2 + 3a", false},
		{"1 + 2 ++ 6", false},
		{"3 + 4 * (2 - 1) * 5", true},
		{"(1+2)*3", true},                     // Верный ввод
		{"((1+2)*3)", true},                   // Верный ввод с двойными скобками
		{"((1+2)*3", false},                   // Неверный ввод, недостающая закрывающая скобка
		{"(1+2)*3)", false},                   // Неверный ввод, недостающая открывающая скобка
		{"(1+2)*(3", false},                   // Неверный ввод, недостающая закрывающая скобка
		{"(1+2)3", false},                     // Неверный ввод, отсутствие оператора между числом и выражением в скобках
		{"(1+2)*3*(", false},                  // Неверный ввод, лишняя открывающая скобка
		{"(1+(2*3", false},                    // Неверный ввод, недостающая закрывающая скобка
		{"(1+2)3*(4+5)", false},               // Неверный ввод, отсутствие оператора между выражениями в скобках
		{"(1+2)*3*(4+5)", true},               // Верный ввод с несколькими уровнями скобок
		{"( 1 + 2 ) * ( 4 + 5 )", true},       // Верный ввод с несколькими уровнями скобок
		{"((1+2)*(4+5))*((6+7)/(8+9))", true}, // Верный ввод с множеством уровней скобок
		//{"(1+2)(3+4)", false},                 // Неверный ввод, отсутствие оператора между выражениями в скобках
	}

	for _, tc := range testCases {
		if result := Validate(tc.infix); result != tc.expected {
			t.Errorf("Expected Validate(%q) to be %v, but got %v", tc.infix, tc.expected, result)
		}
	}
}

func TestValidateAdditionalCases(t *testing.T) {
	testCases := []struct {
		infix    string
		expected bool
	}{
		{"a + b * c", false},                                 // Буквенные переменные
		{"3.14 + 2.5", true},                                 // Float числа
		{"(a + b) * (c - d)", false},                         // Буквенные переменные в скобках
		{"(3.14 + 2.5) * ((6.7 * (3 - 4) / 5) - 4.2)", true}, // Float числа в скобках
		{"3 + 4 * (2 - 1) * 5", true},                        // Выражение без скобок
		{"3 + 4 * (2 - 1) * 5 +", false},                     // Неверный ввод, оператор в конце
		{"3 + 4 * (2 - 1) * 5 /", false},                     // Неверный ввод, оператор в конце
		{"3 + 4 * (2 - 1) * 5 *", false},                     // Неверный ввод, оператор в конце
		{"(3.14 + 2.5) * (6.7 - 4.2", false},                 // Неверный ввод, недостающая закрывающая скобка
		{"3.14 + 2.5) * (6.7 - 4.2)", false},                 // Неверный ввод, лишняя закрывающая скобка
		{"3 + * 4", false},                                   // Неверный ввод, лишний оператор
		{"3 + 4 * 2 -", false},                               // Неверный ввод, оператор в конце
	}

	for _, tc := range testCases {
		if result := Validate(tc.infix); result != tc.expected {
			t.Errorf("Expected Validate(%q) to be %v, but got %v", tc.infix, tc.expected, result)
		}
	}
}

func TestValidateLargeExpressions(t *testing.T) {
	testCases := []struct {
		infix    string
		expected bool
	}{
		{"(1 + 2) * (3 + 4) / (5 + 6) - (7 + 8) * (9 + 10)", true},                    // Сложное выражение с операциями +, -, *, /
		{"((2 * 3) - (4 / 2)) * ((8 / 2) + (6 - 2))", true},                           // Сложное выражение с операциями +, -, *, /
		{"((1 + 2) * (3 - 4) / (5 * 6) - (7 * 8) + (9 - 10))", true},                  // Сложное выражение с операциями +, -, *, /
		{"(a + b) * (c - d) / (e * f) - (g + h) * (i + j)", false},                    // Сложное выражение с переменными и операциями +, -, *, /
		{"(1.2 + 3.4) * (5.6 - 7.8) / (9.1 * 2.3) - (4.5 + 6.7) * (8.9 + 0.1)", true}, // Сложное выражение с числами с плавающей точкой и операциями +, -, *, /
		{"3 + 4 * (2 - 1) * 5", true},                                                 // Простое выражение без скобок
		{"(1 + 2)3 * (4 + 5)", false},                                                 // Неверный ввод, отсутствие оператора между числом и выражением в скобках
		{"(1 + 2) * 3 * (4 + 5)", true},                                               // Верный ввод с несколькими уровнями скобок
		{"((1 + 2) * (4 + 5)) * ((6 + 7) / (8 + 9))", true},                           // Сложное выражение с множеством уровней скобок
		{"(1 + 2)(3 + 4)", false},                                                     // Неверный ввод, отсутствие оператора между выражениями в скобках
		{"3 + 4 * 2 -", false},                                                        // Неверный ввод, оператор в конце
		{"3 + * 4", false},                                                            // Неверный ввод, лишний оператор
	}

	for _, tc := range testCases {
		if result := Validate(tc.infix); result != tc.expected {
			t.Errorf("Expected Validate(%q) to be %v, but got %v", tc.infix, tc.expected, result)
		}
	}
}

func TestValidateMoreExpressions(t *testing.T) {
	testCases := []struct {
		infix    string
		expected bool
	}{
		{"(a + b) * c / (d - e) * (f + g)", false},                                  // Выражение с переменными и операциями +, -, *, /
		{"1 + 2 * 3 - 4 / 5", true},                                                 // Простое выражение с операциями +, -, *, /
		{"(1 + 2 * 3 - 4 / 5) * (6 + 7 - 8 * 9)", true},                             // Большое выражение с операциями +, -, *, /
		{"((2 + 3) * 4 - 5) / (6 + 7) * 8", true},                                   // Сложное выражение с операциями +, -, *, /
		{"(2 + 3) * (4 - 5) / (6 + 7) * 8", true},                                   // Сложное выражение с операциями +, -, *, /
		{"(1 + 2) * (3 + 4) * (5 + 6)", true},                                       // Большое выражение с операциями +, *, ()
		{"(1 + 2) * 3 + 4", true},                                                   // Выражение с операциями +, *
		{"1 + 2 * 3 * 4", true},                                                     // Выражение с операциями +, *
		{"(1 + 2) * 3 / (4 + 5)", true},                                             // Выражение с операциями +, *, /
		{"1 * 2 / (3 + 4) - 5", true},                                               // Выражение с операциями *, /, -
		{"((1 + 2) * 3 - 4) / 5", true},                                             // Выражение с операциями +, -, *, /
		{"((1 + 2) * 3 - 4) / (5 + 6)", true},                                       // Сложное выражение с операциями +, -, *, /
		{"((1 + 2) * 3 - 4) / (5 + 6) * 7", true},                                   // Сложное выражение с операциями +, -, *, /
		{"((1 + 2) * 3 - 4) / (5 + 6) * (7 - 8)", true},                             // Сложное выражение с операциями +, -, *, /
		{"((1 + 2) * 3 - 4) / (5 + 6) * (7 - 8) / (9 + 10)", true},                  // Сложное выражение с операциями +, -, *, /
		{"((1 + 2) * 3 - 4) / (5 + 6) * (7 - 8) / (9 + 10) - 11 * (12 - 13)", true}, // Сложное выражение с операциями +, -, *, /
	}

	for _, tc := range testCases {
		if result := Validate(tc.infix); result != tc.expected {
			t.Errorf("Expected Validate(%q) to be %v, but got %v", tc.infix, tc.expected, result)
		}
	}
}

func TestInfixToPostfix(t *testing.T) {
	testCases := []struct {
		infix    string
		expected string
	}{
		{"1 + 2", "1 2 +"},
		{"1 + 2 * 3", "1 2 3 * +"},
		{"(1 + 2) * 3", "1 2 + 3 *"},
		{"3 + 4 * (2 - 1) * 5", "3 4 2 1 - * 5 * +"},
		{"(1+2)*(3+4)/(5+6)", "1 2 + 3 4 + * 5 6 + /"},
		{"a + b * c", "a b c * +"},
		{"3 + (4 * 2 - 1) * 5", "3 4 2 * 1 - 5 * +"},
		{"1 + 2 * (3 - 4 / 5)", "1 2 3 4 5 / - * +"},
	}

	for _, tc := range testCases {
		result := InfixToPostfix(tc.infix)
		if result != tc.expected {
			t.Errorf("Expected InfixToPostfix(%q) to be %q, but got %q", tc.infix, tc.expected, result)
		}
	}
}
